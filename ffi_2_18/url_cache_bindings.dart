// ignore_for_file: camel_case_types, non_constant_identifier_names, unused_element, unused_field, return_of_invalid_type, void_checks, annotate_overrides, no_leading_underscores_for_local_identifiers, library_private_types_in_public_api,constant_identifier_names,depend_on_referenced_packages
// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;
import 'package:ffi/ffi.dart' as pkg_ffi;

class URLCacheLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  URLCacheLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  URLCacheLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<ObjCSel> _registerName1(String name) {
    final cstr = name.toNativeUtf8();
    final sel = _sel_registerName(cstr.cast());
    pkg_ffi.calloc.free(cstr);
    return sel;
  }

  ffi.Pointer<ObjCSel> _sel_registerName(
    ffi.Pointer<ffi.Char> str,
  ) {
    return __sel_registerName(
      str,
    );
  }

  late final __sel_registerNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCSel> Function(
              ffi.Pointer<ffi.Char>)>>('sel_registerName');
  late final __sel_registerName = __sel_registerNamePtr
      .asFunction<ffi.Pointer<ObjCSel> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ObjCObject> _getClass1(String name) {
    final cstr = name.toNativeUtf8();
    final clazz = _objc_getClass(cstr.cast());
    pkg_ffi.calloc.free(cstr);
    if (clazz == ffi.nullptr) {
      throw Exception('Failed to load Objective-C class: $name');
    }
    return clazz;
  }

  ffi.Pointer<ObjCObject> _objc_getClass(
    ffi.Pointer<ffi.Char> str,
  ) {
    return __objc_getClass(
      str,
    );
  }

  late final __objc_getClassPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ffi.Char>)>>('objc_getClass');
  late final __objc_getClass = __objc_getClassPtr
      .asFunction<ffi.Pointer<ObjCObject> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ObjCObject> _objc_retain(
    ffi.Pointer<ObjCObject> value,
  ) {
    return __objc_retain(
      value,
    );
  }

  late final __objc_retainPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>)>>('objc_retain');
  late final __objc_retain = __objc_retainPtr
      .asFunction<ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>)>();

  void _objc_release(
    ffi.Pointer<ObjCObject> value,
  ) {
    return __objc_release(
      value,
    );
  }

  late final __objc_releasePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ObjCObject>)>>(
          'objc_release');
  late final __objc_release =
      __objc_releasePtr.asFunction<void Function(ffi.Pointer<ObjCObject>)>();

  late final _objc_releaseFinalizer2 =
      ffi.NativeFinalizer(__objc_releasePtr.cast());
  late final _class_NSURLCache1 = _getClass1("NSURLCache");
  bool _objc_msgSend_0(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> clazz,
  ) {
    return __objc_msgSend_0(
      obj,
      sel,
      clazz,
    );
  }

  late final __objc_msgSend_0Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_0 = __objc_msgSend_0Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_isKindOfClass_1 = _registerName1("isKindOfClass:");
  late final _class_NSObject1 = _getClass1("NSObject");
  late final _sel_load1 = _registerName1("load");
  void _objc_msgSend_1(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_1(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_1 = __objc_msgSend_1Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_initialize1 = _registerName1("initialize");
  late final _sel_init1 = _registerName1("init");
  instancetype _objc_msgSend_2(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_2(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_2Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_2 = __objc_msgSend_2Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_new1 = _registerName1("new");
  late final _sel_allocWithZone_1 = _registerName1("allocWithZone:");
  instancetype _objc_msgSend_3(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<_NSZone> zone,
  ) {
    return __objc_msgSend_3(
      obj,
      sel,
      zone,
    );
  }

  late final __objc_msgSend_3Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<_NSZone>)>>('objc_msgSend');
  late final __objc_msgSend_3 = __objc_msgSend_3Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<_NSZone>)>();

  late final _sel_alloc1 = _registerName1("alloc");
  late final _sel_dealloc1 = _registerName1("dealloc");
  late final _sel_finalize1 = _registerName1("finalize");
  late final _sel_copy1 = _registerName1("copy");
  late final _sel_mutableCopy1 = _registerName1("mutableCopy");
  late final _sel_copyWithZone_1 = _registerName1("copyWithZone:");
  late final _sel_mutableCopyWithZone_1 =
      _registerName1("mutableCopyWithZone:");
  late final _sel_instancesRespondToSelector_1 =
      _registerName1("instancesRespondToSelector:");
  bool _objc_msgSend_4(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCSel> aSelector,
  ) {
    return __objc_msgSend_4(
      obj,
      sel,
      aSelector,
    );
  }

  late final __objc_msgSend_4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_4 = __objc_msgSend_4Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCSel>)>();

  late final _class_Protocol1 = _getClass1("Protocol");
  late final _sel_conformsToProtocol_1 = _registerName1("conformsToProtocol:");
  bool _objc_msgSend_5(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> protocol,
  ) {
    return __objc_msgSend_5(
      obj,
      sel,
      protocol,
    );
  }

  late final __objc_msgSend_5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_5 = __objc_msgSend_5Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_methodForSelector_1 = _registerName1("methodForSelector:");
  IMP _objc_msgSend_6(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCSel> aSelector,
  ) {
    return __objc_msgSend_6(
      obj,
      sel,
      aSelector,
    );
  }

  late final __objc_msgSend_6Ptr = _lookup<
      ffi.NativeFunction<
          IMP Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_6 = __objc_msgSend_6Ptr.asFunction<
      IMP Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCSel>)>();

  late final _sel_instanceMethodForSelector_1 =
      _registerName1("instanceMethodForSelector:");
  late final _sel_doesNotRecognizeSelector_1 =
      _registerName1("doesNotRecognizeSelector:");
  void _objc_msgSend_7(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCSel> aSelector,
  ) {
    return __objc_msgSend_7(
      obj,
      sel,
      aSelector,
    );
  }

  late final __objc_msgSend_7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_7 = __objc_msgSend_7Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCSel>)>();

  late final _sel_forwardingTargetForSelector_1 =
      _registerName1("forwardingTargetForSelector:");
  ffi.Pointer<ObjCObject> _objc_msgSend_8(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCSel> aSelector,
  ) {
    return __objc_msgSend_8(
      obj,
      sel,
      aSelector,
    );
  }

  late final __objc_msgSend_8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_8 = __objc_msgSend_8Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCSel>)>();

  late final _class_NSInvocation1 = _getClass1("NSInvocation");
  late final _sel_forwardInvocation_1 = _registerName1("forwardInvocation:");
  void _objc_msgSend_9(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> anInvocation,
  ) {
    return __objc_msgSend_9(
      obj,
      sel,
      anInvocation,
    );
  }

  late final __objc_msgSend_9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_9 = __objc_msgSend_9Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _class_NSMethodSignature1 = _getClass1("NSMethodSignature");
  late final _sel_methodSignatureForSelector_1 =
      _registerName1("methodSignatureForSelector:");
  ffi.Pointer<ObjCObject> _objc_msgSend_10(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCSel> aSelector,
  ) {
    return __objc_msgSend_10(
      obj,
      sel,
      aSelector,
    );
  }

  late final __objc_msgSend_10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_10 = __objc_msgSend_10Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCSel>)>();

  late final _sel_instanceMethodSignatureForSelector_1 =
      _registerName1("instanceMethodSignatureForSelector:");
  late final _sel_allowsWeakReference1 = _registerName1("allowsWeakReference");
  bool _objc_msgSend_11(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_11(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_11 = __objc_msgSend_11Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_retainWeakReference1 = _registerName1("retainWeakReference");
  late final _sel_isSubclassOfClass_1 = _registerName1("isSubclassOfClass:");
  late final _sel_resolveClassMethod_1 = _registerName1("resolveClassMethod:");
  late final _sel_resolveInstanceMethod_1 =
      _registerName1("resolveInstanceMethod:");
  late final _sel_hash1 = _registerName1("hash");
  int _objc_msgSend_12(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_12(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_12Ptr = _lookup<
      ffi.NativeFunction<
          NSUInteger Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_12 = __objc_msgSend_12Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_superclass1 = _registerName1("superclass");
  late final _sel_class1 = _registerName1("class");
  late final _class_NSString1 = _getClass1("NSString");
  late final _sel_stringWithCString_encoding_1 =
      _registerName1("stringWithCString:encoding:");
  ffi.Pointer<ObjCObject> _objc_msgSend_13(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Char> cString,
    int enc,
  ) {
    return __objc_msgSend_13(
      obj,
      sel,
      cString,
      enc,
    );
  }

  late final __objc_msgSend_13Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('objc_msgSend');
  late final __objc_msgSend_13 = __objc_msgSend_13Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ffi.Char>, int)>();

  late final _sel_UTF8String1 = _registerName1("UTF8String");
  ffi.Pointer<ffi.Char> _objc_msgSend_14(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_14(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_14Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_14 = __objc_msgSend_14Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_description1 = _registerName1("description");
  ffi.Pointer<ObjCObject> _objc_msgSend_15(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_15(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_15 = __objc_msgSend_15Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_debugDescription1 = _registerName1("debugDescription");
  late final _sel_sharedURLCache1 = _registerName1("sharedURLCache");
  ffi.Pointer<ObjCObject> _objc_msgSend_16(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_16(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_16 = __objc_msgSend_16Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_setSharedURLCache_1 = _registerName1("setSharedURLCache:");
  void _objc_msgSend_17(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> value,
  ) {
    return __objc_msgSend_17(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_17 = __objc_msgSend_17Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_initWithMemoryCapacity_diskCapacity_diskPath_1 =
      _registerName1("initWithMemoryCapacity:diskCapacity:diskPath:");
  instancetype _objc_msgSend_18(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int memoryCapacity,
    int diskCapacity,
    ffi.Pointer<ObjCObject> path,
  ) {
    return __objc_msgSend_18(
      obj,
      sel,
      memoryCapacity,
      diskCapacity,
      path,
    );
  }

  late final __objc_msgSend_18Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              NSUInteger,
              NSUInteger,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_18 = __objc_msgSend_18Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int,
          int, ffi.Pointer<ObjCObject>)>();

  late final _class_NSURL1 = _getClass1("NSURL");
  late final _sel_initWithMemoryCapacity_diskCapacity_directoryURL_1 =
      _registerName1("initWithMemoryCapacity:diskCapacity:directoryURL:");
  instancetype _objc_msgSend_19(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int memoryCapacity,
    int diskCapacity,
    ffi.Pointer<ObjCObject> directoryURL,
  ) {
    return __objc_msgSend_19(
      obj,
      sel,
      memoryCapacity,
      diskCapacity,
      directoryURL,
    );
  }

  late final __objc_msgSend_19Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              NSUInteger,
              NSUInteger,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_19 = __objc_msgSend_19Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int,
          int, ffi.Pointer<ObjCObject>)>();

  late final _class_NSCachedURLResponse1 = _getClass1("NSCachedURLResponse");
  late final _class_NSURLResponse1 = _getClass1("NSURLResponse");
  late final _class_NSData1 = _getClass1("NSData");
  late final _sel_initWithResponse_data_1 =
      _registerName1("initWithResponse:data:");
  instancetype _objc_msgSend_20(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> response,
    ffi.Pointer<ObjCObject> data,
  ) {
    return __objc_msgSend_20(
      obj,
      sel,
      response,
      data,
    );
  }

  late final __objc_msgSend_20Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_20 = __objc_msgSend_20Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  late final _class_NSDictionary1 = _getClass1("NSDictionary");
  late final _sel_initWithResponse_data_userInfo_storagePolicy_1 =
      _registerName1("initWithResponse:data:userInfo:storagePolicy:");
  instancetype _objc_msgSend_21(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> response,
    ffi.Pointer<ObjCObject> data,
    ffi.Pointer<ObjCObject> userInfo,
    int storagePolicy,
  ) {
    return __objc_msgSend_21(
      obj,
      sel,
      response,
      data,
      userInfo,
      storagePolicy,
    );
  }

  late final __objc_msgSend_21Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Int32)>>('objc_msgSend');
  late final __objc_msgSend_21 = __objc_msgSend_21Ptr.asFunction<
      instancetype Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          int)>();

  late final _sel_response1 = _registerName1("response");
  ffi.Pointer<ObjCObject> _objc_msgSend_22(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_22(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_22 = __objc_msgSend_22Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_data1 = _registerName1("data");
  ffi.Pointer<ObjCObject> _objc_msgSend_23(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_23(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_23 = __objc_msgSend_23Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_userInfo1 = _registerName1("userInfo");
  ffi.Pointer<ObjCObject> _objc_msgSend_24(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_24(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_24 = __objc_msgSend_24Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_storagePolicy1 = _registerName1("storagePolicy");
  int _objc_msgSend_25(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_25(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_25Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_25 = __objc_msgSend_25Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _class_NSURLRequest1 = _getClass1("NSURLRequest");
  late final _sel_cachedResponseForRequest_1 =
      _registerName1("cachedResponseForRequest:");
  ffi.Pointer<ObjCObject> _objc_msgSend_26(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> request,
  ) {
    return __objc_msgSend_26(
      obj,
      sel,
      request,
    );
  }

  late final __objc_msgSend_26Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_26 = __objc_msgSend_26Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_storeCachedResponse_forRequest_1 =
      _registerName1("storeCachedResponse:forRequest:");
  void _objc_msgSend_27(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> cachedResponse,
    ffi.Pointer<ObjCObject> request,
  ) {
    return __objc_msgSend_27(
      obj,
      sel,
      cachedResponse,
      request,
    );
  }

  late final __objc_msgSend_27Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_27 = __objc_msgSend_27Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  late final _sel_removeCachedResponseForRequest_1 =
      _registerName1("removeCachedResponseForRequest:");
  void _objc_msgSend_28(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> request,
  ) {
    return __objc_msgSend_28(
      obj,
      sel,
      request,
    );
  }

  late final __objc_msgSend_28Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_28 = __objc_msgSend_28Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_removeAllCachedResponses1 =
      _registerName1("removeAllCachedResponses");
  late final _class_NSDate1 = _getClass1("NSDate");
  late final _sel_removeCachedResponsesSinceDate_1 =
      _registerName1("removeCachedResponsesSinceDate:");
  void _objc_msgSend_29(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> date,
  ) {
    return __objc_msgSend_29(
      obj,
      sel,
      date,
    );
  }

  late final __objc_msgSend_29Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_29 = __objc_msgSend_29Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_memoryCapacity1 = _registerName1("memoryCapacity");
  late final _sel_setMemoryCapacity_1 = _registerName1("setMemoryCapacity:");
  void _objc_msgSend_30(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_30(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_30Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSUInteger)>>('objc_msgSend');
  late final __objc_msgSend_30 = __objc_msgSend_30Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_diskCapacity1 = _registerName1("diskCapacity");
  late final _sel_setDiskCapacity_1 = _registerName1("setDiskCapacity:");
  late final _sel_currentMemoryUsage1 = _registerName1("currentMemoryUsage");
  late final _sel_currentDiskUsage1 = _registerName1("currentDiskUsage");
  late final _class_NSURLSessionDataTask1 = _getClass1("NSURLSessionDataTask");
  late final _sel_storeCachedResponse_forDataTask_1 =
      _registerName1("storeCachedResponse:forDataTask:");
  void _objc_msgSend_31(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> cachedResponse,
    ffi.Pointer<ObjCObject> dataTask,
  ) {
    return __objc_msgSend_31(
      obj,
      sel,
      cachedResponse,
      dataTask,
    );
  }

  late final __objc_msgSend_31Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_31 = __objc_msgSend_31Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  ffi.Pointer<_ObjCBlockDesc> _newBlockDesc1() {
    final d =
        pkg_ffi.calloc.allocate<_ObjCBlockDesc>(ffi.sizeOf<_ObjCBlockDesc>());
    d.ref.size = ffi.sizeOf<_ObjCBlock>();
    return d;
  }

  late final _objc_block_desc1 = _newBlockDesc1();
  late final _objc_concrete_global_block1 =
      _lookup<ffi.Void>('_NSConcreteGlobalBlock');
  ffi.Pointer<_ObjCBlock> _newBlock1(
      ffi.Pointer<ffi.Void> invoke, ffi.Pointer<ffi.Void> target) {
    final b = pkg_ffi.calloc.allocate<_ObjCBlock>(ffi.sizeOf<_ObjCBlock>());
    b.ref.isa = _objc_concrete_global_block1;
    b.ref.invoke = invoke;
    b.ref.target = target;
    b.ref.descriptor = _objc_block_desc1;
    final copy = _Block_copy(b.cast()).cast<_ObjCBlock>();
    pkg_ffi.calloc.free(b);
    return copy;
  }

  ffi.Pointer<ffi.Void> _Block_copy(
    ffi.Pointer<ffi.Void> value,
  ) {
    return __Block_copy(
      value,
    );
  }

  late final __Block_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>)>>('_Block_copy');
  late final __Block_copy = __Block_copyPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  void _Block_release(
    ffi.Pointer<ffi.Void> value,
  ) {
    return __Block_release(
      value,
    );
  }

  late final __Block_releasePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          '_Block_release');
  late final __Block_release =
      __Block_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  late final _objc_releaseFinalizer11 =
      ffi.NativeFinalizer(__Block_releasePtr.cast());
  late final _sel_getCachedResponseForDataTask_completionHandler_1 =
      _registerName1("getCachedResponseForDataTask:completionHandler:");
  void _objc_msgSend_32(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> dataTask,
    ffi.Pointer<_ObjCBlock> completionHandler,
  ) {
    return __objc_msgSend_32(
      obj,
      sel,
      dataTask,
      completionHandler,
    );
  }

  late final __objc_msgSend_32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_32 = __objc_msgSend_32Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<_ObjCBlock>)>();

  late final _sel_removeCachedResponseForDataTask_1 =
      _registerName1("removeCachedResponseForDataTask:");
  void _objc_msgSend_33(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> dataTask,
  ) {
    return __objc_msgSend_33(
      obj,
      sel,
      dataTask,
    );
  }

  late final __objc_msgSend_33Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_33 = __objc_msgSend_33Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();
}

class _ObjCWrapper implements ffi.Finalizable {
  final ffi.Pointer<ObjCObject> _id;
  final URLCacheLibrary _lib;
  bool _pendingRelease;

  _ObjCWrapper._(this._id, this._lib,
      {bool retain = false, bool release = false})
      : _pendingRelease = release {
    if (retain) {
      _lib._objc_retain(_id.cast());
    }
    if (release) {
      _lib._objc_releaseFinalizer2.attach(this, _id.cast(), detach: this);
    }
  }

  /// Releases the reference to the underlying ObjC object held by this wrapper.
  /// Throws a StateError if this wrapper doesn't currently hold a reference.
  void release() {
    if (_pendingRelease) {
      _pendingRelease = false;
      _lib._objc_release(_id.cast());
      _lib._objc_releaseFinalizer2.detach(this);
    } else {
      throw StateError(
          'Released an ObjC object that was unowned or already released.');
    }
  }

  @override
  bool operator ==(Object other) {
    return other is _ObjCWrapper && _id == other._id;
  }

  @override
  int get hashCode => _id.hashCode;
}

class NSURLCache extends NSObject {
  NSURLCache._(ffi.Pointer<ObjCObject> id, URLCacheLibrary lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURLCache] that points to the same underlying object as [other].
  static NSURLCache castFrom<T extends _ObjCWrapper>(T other) {
    return NSURLCache._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSURLCache] that wraps the given raw object pointer.
  static NSURLCache castFromPointer(
      URLCacheLibrary lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURLCache._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURLCache].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSURLCache1);
  }

  /// !
  /// @property sharedURLCache
  /// @abstract Returns the shared NSURLCache instance or
  /// sets the NSURLCache instance shared by all clients of
  /// the current process. This will be the new object returned when
  /// calls to the <tt>sharedURLCache</tt> method are made.
  /// @discussion Unless set explicitly through a call to
  /// <tt>+setSharedURLCache:</tt>, this method returns an NSURLCache
  /// instance created with the following default values:
  /// <ul>
  /// <li>Memory capacity: 4 megabytes (4 * 1024 * 1024 bytes)
  /// <li>Disk capacity: 20 megabytes (20 * 1024 * 1024 bytes)
  /// <li>Disk path: <nobr>(user home directory)/Library/Caches/(application bundle id)</nobr>
  /// </ul>
  /// <p>Users who do not have special caching requirements or
  /// constraints should find the default shared cache instance
  /// acceptable. If this default shared cache instance is not
  /// acceptable, <tt>+setSharedURLCache:</tt> can be called to set a
  /// different NSURLCache instance to be returned from this method.
  /// Callers should take care to ensure that the setter is called
  /// at a time when no other caller has a reference to the previously-set
  /// shared URL cache. This is to prevent storing cache data from
  /// becoming unexpectedly unretrievable.
  /// @result the shared NSURLCache instance.
  static NSURLCache? getSharedURLCache(URLCacheLibrary _lib) {
    final _ret = _lib._objc_msgSend_16(
        _lib._class_NSURLCache1, _lib._sel_sharedURLCache1);
    return _ret.address == 0
        ? null
        : NSURLCache._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @property sharedURLCache
  /// @abstract Returns the shared NSURLCache instance or
  /// sets the NSURLCache instance shared by all clients of
  /// the current process. This will be the new object returned when
  /// calls to the <tt>sharedURLCache</tt> method are made.
  /// @discussion Unless set explicitly through a call to
  /// <tt>+setSharedURLCache:</tt>, this method returns an NSURLCache
  /// instance created with the following default values:
  /// <ul>
  /// <li>Memory capacity: 4 megabytes (4 * 1024 * 1024 bytes)
  /// <li>Disk capacity: 20 megabytes (20 * 1024 * 1024 bytes)
  /// <li>Disk path: <nobr>(user home directory)/Library/Caches/(application bundle id)</nobr>
  /// </ul>
  /// <p>Users who do not have special caching requirements or
  /// constraints should find the default shared cache instance
  /// acceptable. If this default shared cache instance is not
  /// acceptable, <tt>+setSharedURLCache:</tt> can be called to set a
  /// different NSURLCache instance to be returned from this method.
  /// Callers should take care to ensure that the setter is called
  /// at a time when no other caller has a reference to the previously-set
  /// shared URL cache. This is to prevent storing cache data from
  /// becoming unexpectedly unretrievable.
  /// @result the shared NSURLCache instance.
  static void setSharedURLCache(URLCacheLibrary _lib, NSURLCache? value) {
    _lib._objc_msgSend_17(_lib._class_NSURLCache1,
        _lib._sel_setSharedURLCache_1, value?._id ?? ffi.nullptr);
  }

  /// !
  /// @method initWithMemoryCapacity:diskCapacity:diskPath:
  /// @abstract Initializes an NSURLCache with the given capacity and
  /// path.
  /// @discussion The returned NSURLCache is backed by disk, so
  /// developers can be more liberal with space when choosing the
  /// capacity for this kind of cache. A disk cache measured in the tens
  /// of megabytes should be acceptable in most cases.
  /// @param memoryCapacity the capacity, measured in bytes, for the cache in memory.
  /// @param diskCapacity the capacity, measured in bytes, for the cache on disk.
  /// @param path the path on disk where the cache data is stored.
  /// @result an initialized NSURLCache, with the given capacity, backed
  /// by disk.
  NSURLCache initWithMemoryCapacity_diskCapacity_diskPath_(
      int memoryCapacity, int diskCapacity, NSString? path) {
    final _ret = _lib._objc_msgSend_18(
        _id,
        _lib._sel_initWithMemoryCapacity_diskCapacity_diskPath_1,
        memoryCapacity,
        diskCapacity,
        path?._id ?? ffi.nullptr);
    return NSURLCache._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @method initWithMemoryCapacity:diskCapacity:directoryURL:
  /// @abstract Initializes an NSURLCache with the given capacity and directory.
  /// @param memoryCapacity the capacity, measured in bytes, for the cache in memory. Or 0 to disable memory cache.
  /// @param diskCapacity the capacity, measured in bytes, for the cache on disk. Or 0 to disable disk cache.
  /// @param directoryURL the path to a directory on disk where the cache data is stored. Or nil for default directory.
  /// @result an initialized NSURLCache, with the given capacity, optionally backed by disk.
  NSURLCache initWithMemoryCapacity_diskCapacity_directoryURL_(
      int memoryCapacity, int diskCapacity, NSURL? directoryURL) {
    final _ret = _lib._objc_msgSend_19(
        _id,
        _lib._sel_initWithMemoryCapacity_diskCapacity_directoryURL_1,
        memoryCapacity,
        diskCapacity,
        directoryURL?._id ?? ffi.nullptr);
    return NSURLCache._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @method cachedResponseForRequest:
  /// @abstract Returns the NSCachedURLResponse stored in the cache with
  /// the given request.
  /// @discussion The method returns nil if there is no
  /// NSCachedURLResponse stored using the given request.
  /// @param request the NSURLRequest to use as a key for the lookup.
  /// @result The NSCachedURLResponse stored in the cache with the given
  /// request, or nil if there is no NSCachedURLResponse stored with the
  /// given request.
  NSCachedURLResponse cachedResponseForRequest_(NSURLRequest? request) {
    final _ret = _lib._objc_msgSend_26(
        _id, _lib._sel_cachedResponseForRequest_1, request?._id ?? ffi.nullptr);
    return NSCachedURLResponse._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @method storeCachedResponse:forRequest:
  /// @abstract Stores the given NSCachedURLResponse in the cache using
  /// the given request.
  /// @param cachedResponse The cached response to store.
  /// @param request the NSURLRequest to use as a key for the storage.
  void storeCachedResponse_forRequest_(
      NSCachedURLResponse? cachedResponse, NSURLRequest? request) {
    return _lib._objc_msgSend_27(
        _id,
        _lib._sel_storeCachedResponse_forRequest_1,
        cachedResponse?._id ?? ffi.nullptr,
        request?._id ?? ffi.nullptr);
  }

  /// !
  /// @method removeCachedResponseForRequest:
  /// @abstract Removes the NSCachedURLResponse from the cache that is
  /// stored using the given request.
  /// @discussion No action is taken if there is no NSCachedURLResponse
  /// stored with the given request.
  /// @param request the NSURLRequest to use as a key for the lookup.
  void removeCachedResponseForRequest_(NSURLRequest? request) {
    return _lib._objc_msgSend_28(
        _id,
        _lib._sel_removeCachedResponseForRequest_1,
        request?._id ?? ffi.nullptr);
  }

  /// !
  /// @method removeAllCachedResponses
  /// @abstract Clears the given cache, removing all NSCachedURLResponse
  /// objects that it stores.
  void removeAllCachedResponses() {
    return _lib._objc_msgSend_1(_id, _lib._sel_removeAllCachedResponses1);
  }

  /// !
  /// @method removeCachedResponsesSince:
  /// @abstract Clears the given cache of any cached responses since the provided date.
  void removeCachedResponsesSinceDate_(NSDate? date) {
    return _lib._objc_msgSend_29(_id,
        _lib._sel_removeCachedResponsesSinceDate_1, date?._id ?? ffi.nullptr);
  }

  /// !
  /// @abstract In-memory capacity of the receiver.
  /// @discussion At the time this call is made, the in-memory cache will truncate its contents to the size given, if necessary.
  /// @result The in-memory capacity, measured in bytes, for the receiver.
  int get memoryCapacity {
    return _lib._objc_msgSend_12(_id, _lib._sel_memoryCapacity1);
  }

  /// !
  /// @abstract In-memory capacity of the receiver.
  /// @discussion At the time this call is made, the in-memory cache will truncate its contents to the size given, if necessary.
  /// @result The in-memory capacity, measured in bytes, for the receiver.
  set memoryCapacity(int value) {
    _lib._objc_msgSend_30(_id, _lib._sel_setMemoryCapacity_1, value);
  }

  /// !
  /// @abstract The on-disk capacity of the receiver.
  /// @discussion The on-disk capacity, measured in bytes, for the receiver. On mutation the on-disk cache will truncate its contents to the size given, if necessary.
  int get diskCapacity {
    return _lib._objc_msgSend_12(_id, _lib._sel_diskCapacity1);
  }

  /// !
  /// @abstract The on-disk capacity of the receiver.
  /// @discussion The on-disk capacity, measured in bytes, for the receiver. On mutation the on-disk cache will truncate its contents to the size given, if necessary.
  set diskCapacity(int value) {
    _lib._objc_msgSend_30(_id, _lib._sel_setDiskCapacity_1, value);
  }

  /// !
  /// @abstract Returns the current amount of space consumed by the
  /// in-memory cache of the receiver.
  /// @discussion This size, measured in bytes, indicates the current
  /// usage of the in-memory cache.
  /// @result the current usage of the in-memory cache of the receiver.
  int get currentMemoryUsage {
    return _lib._objc_msgSend_12(_id, _lib._sel_currentMemoryUsage1);
  }

  /// !
  /// @abstract Returns the current amount of space consumed by the
  /// on-disk cache of the receiver.
  /// @discussion This size, measured in bytes, indicates the current
  /// usage of the on-disk cache.
  /// @result the current usage of the on-disk cache of the receiver.
  int get currentDiskUsage {
    return _lib._objc_msgSend_12(_id, _lib._sel_currentDiskUsage1);
  }

  void storeCachedResponse_forDataTask_(
      NSCachedURLResponse? cachedResponse, NSURLSessionDataTask? dataTask) {
    return _lib._objc_msgSend_31(
        _id,
        _lib._sel_storeCachedResponse_forDataTask_1,
        cachedResponse?._id ?? ffi.nullptr,
        dataTask?._id ?? ffi.nullptr);
  }

  void getCachedResponseForDataTask_completionHandler_(
      NSURLSessionDataTask? dataTask, ObjCBlock completionHandler) {
    return _lib._objc_msgSend_32(
        _id,
        _lib._sel_getCachedResponseForDataTask_completionHandler_1,
        dataTask?._id ?? ffi.nullptr,
        completionHandler._id);
  }

  void removeCachedResponseForDataTask_(NSURLSessionDataTask? dataTask) {
    return _lib._objc_msgSend_33(
        _id,
        _lib._sel_removeCachedResponseForDataTask_1,
        dataTask?._id ?? ffi.nullptr);
  }

  static NSURLCache new1(URLCacheLibrary _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSURLCache1, _lib._sel_new1);
    return NSURLCache._(_ret, _lib, retain: false, release: true);
  }

  static NSURLCache alloc(URLCacheLibrary _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSURLCache1, _lib._sel_alloc1);
    return NSURLCache._(_ret, _lib, retain: false, release: true);
  }
}

class ObjCSel extends ffi.Opaque {}

class ObjCObject extends ffi.Opaque {}

class NSObject extends _ObjCWrapper {
  NSObject._(ffi.Pointer<ObjCObject> id, URLCacheLibrary lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSObject] that points to the same underlying object as [other].
  static NSObject castFrom<T extends _ObjCWrapper>(T other) {
    return NSObject._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSObject] that wraps the given raw object pointer.
  static NSObject castFromPointer(
      URLCacheLibrary lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSObject._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSObject].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSObject1);
  }

  static void load(URLCacheLibrary _lib) {
    return _lib._objc_msgSend_1(_lib._class_NSObject1, _lib._sel_load1);
  }

  static void initialize(URLCacheLibrary _lib) {
    return _lib._objc_msgSend_1(_lib._class_NSObject1, _lib._sel_initialize1);
  }

  NSObject init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSObject new1(URLCacheLibrary _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSObject1, _lib._sel_new1);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  static NSObject allocWithZone_(
      URLCacheLibrary _lib, ffi.Pointer<_NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_NSObject1, _lib._sel_allocWithZone_1, zone);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  static NSObject alloc(URLCacheLibrary _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSObject1, _lib._sel_alloc1);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  void dealloc() {
    return _lib._objc_msgSend_1(_id, _lib._sel_dealloc1);
  }

  void finalize() {
    return _lib._objc_msgSend_1(_id, _lib._sel_finalize1);
  }

  NSObject copy() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_copy1);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  NSObject mutableCopy() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_mutableCopy1);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  static NSObject copyWithZone_(
      URLCacheLibrary _lib, ffi.Pointer<_NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_NSObject1, _lib._sel_copyWithZone_1, zone);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  static NSObject mutableCopyWithZone_(
      URLCacheLibrary _lib, ffi.Pointer<_NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_NSObject1, _lib._sel_mutableCopyWithZone_1, zone);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  static bool instancesRespondToSelector_(
      URLCacheLibrary _lib, ffi.Pointer<ObjCSel> aSelector) {
    return _lib._objc_msgSend_4(_lib._class_NSObject1,
        _lib._sel_instancesRespondToSelector_1, aSelector);
  }

  static bool conformsToProtocol_(URLCacheLibrary _lib, Protocol? protocol) {
    return _lib._objc_msgSend_5(_lib._class_NSObject1,
        _lib._sel_conformsToProtocol_1, protocol?._id ?? ffi.nullptr);
  }

  IMP methodForSelector_(ffi.Pointer<ObjCSel> aSelector) {
    return _lib._objc_msgSend_6(_id, _lib._sel_methodForSelector_1, aSelector);
  }

  static IMP instanceMethodForSelector_(
      URLCacheLibrary _lib, ffi.Pointer<ObjCSel> aSelector) {
    return _lib._objc_msgSend_6(_lib._class_NSObject1,
        _lib._sel_instanceMethodForSelector_1, aSelector);
  }

  void doesNotRecognizeSelector_(ffi.Pointer<ObjCSel> aSelector) {
    return _lib._objc_msgSend_7(
        _id, _lib._sel_doesNotRecognizeSelector_1, aSelector);
  }

  NSObject forwardingTargetForSelector_(ffi.Pointer<ObjCSel> aSelector) {
    final _ret = _lib._objc_msgSend_8(
        _id, _lib._sel_forwardingTargetForSelector_1, aSelector);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  void forwardInvocation_(NSInvocation? anInvocation) {
    return _lib._objc_msgSend_9(
        _id, _lib._sel_forwardInvocation_1, anInvocation?._id ?? ffi.nullptr);
  }

  NSMethodSignature methodSignatureForSelector_(
      ffi.Pointer<ObjCSel> aSelector) {
    final _ret = _lib._objc_msgSend_10(
        _id, _lib._sel_methodSignatureForSelector_1, aSelector);
    return NSMethodSignature._(_ret, _lib, retain: true, release: true);
  }

  static NSMethodSignature instanceMethodSignatureForSelector_(
      URLCacheLibrary _lib, ffi.Pointer<ObjCSel> aSelector) {
    final _ret = _lib._objc_msgSend_10(_lib._class_NSObject1,
        _lib._sel_instanceMethodSignatureForSelector_1, aSelector);
    return NSMethodSignature._(_ret, _lib, retain: true, release: true);
  }

  bool allowsWeakReference() {
    return _lib._objc_msgSend_11(_id, _lib._sel_allowsWeakReference1);
  }

  bool retainWeakReference() {
    return _lib._objc_msgSend_11(_id, _lib._sel_retainWeakReference1);
  }

  static bool isSubclassOfClass_(URLCacheLibrary _lib, NSObject aClass) {
    return _lib._objc_msgSend_0(
        _lib._class_NSObject1, _lib._sel_isSubclassOfClass_1, aClass._id);
  }

  static bool resolveClassMethod_(
      URLCacheLibrary _lib, ffi.Pointer<ObjCSel> sel) {
    return _lib._objc_msgSend_4(
        _lib._class_NSObject1, _lib._sel_resolveClassMethod_1, sel);
  }

  static bool resolveInstanceMethod_(
      URLCacheLibrary _lib, ffi.Pointer<ObjCSel> sel) {
    return _lib._objc_msgSend_4(
        _lib._class_NSObject1, _lib._sel_resolveInstanceMethod_1, sel);
  }

  static int hash(URLCacheLibrary _lib) {
    return _lib._objc_msgSend_12(_lib._class_NSObject1, _lib._sel_hash1);
  }

  static NSObject superclass(URLCacheLibrary _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSObject1, _lib._sel_superclass1);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSObject class1(URLCacheLibrary _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSObject1, _lib._sel_class1);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSString description(URLCacheLibrary _lib) {
    final _ret =
        _lib._objc_msgSend_15(_lib._class_NSObject1, _lib._sel_description1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  static NSString debugDescription(URLCacheLibrary _lib) {
    final _ret = _lib._objc_msgSend_15(
        _lib._class_NSObject1, _lib._sel_debugDescription1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }
}

typedef instancetype = ffi.Pointer<ObjCObject>;

class _NSZone extends ffi.Opaque {}

class Protocol extends _ObjCWrapper {
  Protocol._(ffi.Pointer<ObjCObject> id, URLCacheLibrary lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [Protocol] that points to the same underlying object as [other].
  static Protocol castFrom<T extends _ObjCWrapper>(T other) {
    return Protocol._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [Protocol] that wraps the given raw object pointer.
  static Protocol castFromPointer(
      URLCacheLibrary lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return Protocol._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [Protocol].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_Protocol1);
  }
}

typedef IMP = ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>;

class NSInvocation extends _ObjCWrapper {
  NSInvocation._(ffi.Pointer<ObjCObject> id, URLCacheLibrary lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSInvocation] that points to the same underlying object as [other].
  static NSInvocation castFrom<T extends _ObjCWrapper>(T other) {
    return NSInvocation._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSInvocation] that wraps the given raw object pointer.
  static NSInvocation castFromPointer(
      URLCacheLibrary lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSInvocation._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSInvocation].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSInvocation1);
  }
}

class NSMethodSignature extends _ObjCWrapper {
  NSMethodSignature._(ffi.Pointer<ObjCObject> id, URLCacheLibrary lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSMethodSignature] that points to the same underlying object as [other].
  static NSMethodSignature castFrom<T extends _ObjCWrapper>(T other) {
    return NSMethodSignature._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSMethodSignature] that wraps the given raw object pointer.
  static NSMethodSignature castFromPointer(
      URLCacheLibrary lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSMethodSignature._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSMethodSignature].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSMethodSignature1);
  }
}

typedef NSUInteger = ffi.UnsignedLong;

class NSString extends _ObjCWrapper {
  NSString._(ffi.Pointer<ObjCObject> id, URLCacheLibrary lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSString] that points to the same underlying object as [other].
  static NSString castFrom<T extends _ObjCWrapper>(T other) {
    return NSString._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSString] that wraps the given raw object pointer.
  static NSString castFromPointer(
      URLCacheLibrary lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSString._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSString].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSString1);
  }

  factory NSString(URLCacheLibrary _lib, String str) {
    final cstr = str.toNativeUtf8();
    final nsstr = stringWithCString_encoding_(_lib, cstr.cast(), 4 /* UTF8 */);
    pkg_ffi.calloc.free(cstr);
    return nsstr;
  }

  @override
  String toString() => (UTF8String).cast<pkg_ffi.Utf8>().toDartString();
  static NSString stringWithCString_encoding_(
      URLCacheLibrary _lib, ffi.Pointer<ffi.Char> cString, int enc) {
    final _ret = _lib._objc_msgSend_13(_lib._class_NSString1,
        _lib._sel_stringWithCString_encoding_1, cString, enc);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  ffi.Pointer<ffi.Char> get UTF8String {
    return _lib._objc_msgSend_14(_id, _lib._sel_UTF8String1);
  }
}

extension StringToNSString on String {
  NSString toNSString(URLCacheLibrary lib) => NSString(lib, this);
}

class NSURL extends _ObjCWrapper {
  NSURL._(ffi.Pointer<ObjCObject> id, URLCacheLibrary lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURL] that points to the same underlying object as [other].
  static NSURL castFrom<T extends _ObjCWrapper>(T other) {
    return NSURL._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSURL] that wraps the given raw object pointer.
  static NSURL castFromPointer(
      URLCacheLibrary lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURL._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURL].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSURL1);
  }
}

/// !
/// @class NSCachedURLResponse
/// NSCachedURLResponse is a class whose objects functions as a wrapper for
/// objects that are stored in the framework's caching system.
/// It is used to maintain characteristics and attributes of a cached
/// object.
class NSCachedURLResponse extends NSObject {
  NSCachedURLResponse._(ffi.Pointer<ObjCObject> id, URLCacheLibrary lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSCachedURLResponse] that points to the same underlying object as [other].
  static NSCachedURLResponse castFrom<T extends _ObjCWrapper>(T other) {
    return NSCachedURLResponse._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSCachedURLResponse] that wraps the given raw object pointer.
  static NSCachedURLResponse castFromPointer(
      URLCacheLibrary lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSCachedURLResponse._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSCachedURLResponse].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSCachedURLResponse1);
  }

  /// !
  /// @method initWithResponse:data
  /// @abstract Initializes an NSCachedURLResponse with the given
  /// response and data.
  /// @discussion A default NSURLCacheStoragePolicy is used for
  /// NSCachedURLResponse objects initialized with this method:
  /// NSURLCacheStorageAllowed.
  /// @param response a NSURLResponse object.
  /// @param data an NSData object representing the URL content
  /// corresponding to the given response.
  /// @result an initialized NSCachedURLResponse.
  NSCachedURLResponse initWithResponse_data_(
      NSURLResponse? response, NSData? data) {
    final _ret = _lib._objc_msgSend_20(_id, _lib._sel_initWithResponse_data_1,
        response?._id ?? ffi.nullptr, data?._id ?? ffi.nullptr);
    return NSCachedURLResponse._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @method initWithResponse:data:userInfo:storagePolicy:
  /// @abstract Initializes an NSCachedURLResponse with the given
  /// response, data, user-info dictionary, and storage policy.
  /// @param response a NSURLResponse object.
  /// @param data an NSData object representing the URL content
  /// corresponding to the given response.
  /// @param userInfo a dictionary user-specified information to be
  /// stored with the NSCachedURLResponse.
  /// @param storagePolicy an NSURLCacheStoragePolicy constant.
  /// @result an initialized NSCachedURLResponse.
  NSCachedURLResponse initWithResponse_data_userInfo_storagePolicy_(
      NSURLResponse? response,
      NSData? data,
      NSDictionary? userInfo,
      int storagePolicy) {
    final _ret = _lib._objc_msgSend_21(
        _id,
        _lib._sel_initWithResponse_data_userInfo_storagePolicy_1,
        response?._id ?? ffi.nullptr,
        data?._id ?? ffi.nullptr,
        userInfo?._id ?? ffi.nullptr,
        storagePolicy);
    return NSCachedURLResponse._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @abstract Returns the response wrapped by this instance.
  /// @result The response wrapped by this instance.
  NSURLResponse? get response {
    final _ret = _lib._objc_msgSend_22(_id, _lib._sel_response1);
    return _ret.address == 0
        ? null
        : NSURLResponse._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @abstract Returns the data of the receiver.
  /// @result The data of the receiver.
  NSData? get data {
    final _ret = _lib._objc_msgSend_23(_id, _lib._sel_data1);
    return _ret.address == 0
        ? null
        : NSData._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @abstract Returns the userInfo dictionary of the receiver.
  /// @result The userInfo dictionary of the receiver.
  NSDictionary? get userInfo {
    final _ret = _lib._objc_msgSend_24(_id, _lib._sel_userInfo1);
    return _ret.address == 0
        ? null
        : NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @abstract Returns the NSURLCacheStoragePolicy constant of the receiver.
  /// @result The NSURLCacheStoragePolicy constant of the receiver.
  int get storagePolicy {
    return _lib._objc_msgSend_25(_id, _lib._sel_storagePolicy1);
  }

  static NSCachedURLResponse new1(URLCacheLibrary _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSCachedURLResponse1, _lib._sel_new1);
    return NSCachedURLResponse._(_ret, _lib, retain: false, release: true);
  }

  static NSCachedURLResponse alloc(URLCacheLibrary _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_NSCachedURLResponse1, _lib._sel_alloc1);
    return NSCachedURLResponse._(_ret, _lib, retain: false, release: true);
  }
}

class NSURLResponse extends _ObjCWrapper {
  NSURLResponse._(ffi.Pointer<ObjCObject> id, URLCacheLibrary lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURLResponse] that points to the same underlying object as [other].
  static NSURLResponse castFrom<T extends _ObjCWrapper>(T other) {
    return NSURLResponse._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSURLResponse] that wraps the given raw object pointer.
  static NSURLResponse castFromPointer(
      URLCacheLibrary lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURLResponse._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURLResponse].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSURLResponse1);
  }
}

class NSData extends _ObjCWrapper {
  NSData._(ffi.Pointer<ObjCObject> id, URLCacheLibrary lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSData] that points to the same underlying object as [other].
  static NSData castFrom<T extends _ObjCWrapper>(T other) {
    return NSData._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSData] that wraps the given raw object pointer.
  static NSData castFromPointer(
      URLCacheLibrary lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSData._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSData].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSData1);
  }
}

class NSDictionary extends _ObjCWrapper {
  NSDictionary._(ffi.Pointer<ObjCObject> id, URLCacheLibrary lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSDictionary] that points to the same underlying object as [other].
  static NSDictionary castFrom<T extends _ObjCWrapper>(T other) {
    return NSDictionary._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSDictionary] that wraps the given raw object pointer.
  static NSDictionary castFromPointer(
      URLCacheLibrary lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSDictionary._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSDictionary].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSDictionary1);
  }
}

/// !
/// @enum NSURLCacheStoragePolicy
///
/// @discussion The NSURLCacheStoragePolicy enum defines constants that
/// can be used to specify the type of storage that is allowable for an
/// NSCachedURLResponse object that is to be stored in an NSURLCache.
///
/// @constant NSURLCacheStorageAllowed Specifies that storage in an
/// NSURLCache is allowed without restriction.
///
/// @constant NSURLCacheStorageAllowedInMemoryOnly Specifies that
/// storage in an NSURLCache is allowed; however storage should be
/// done in memory only, no disk storage should be done.
///
/// @constant NSURLCacheStorageNotAllowed Specifies that storage in an
/// NSURLCache is not allowed in any fashion, either in memory or on
/// disk.
abstract class NSURLCacheStoragePolicy {
  static const int NSURLCacheStorageAllowed = 0;
  static const int NSURLCacheStorageAllowedInMemoryOnly = 1;
  static const int NSURLCacheStorageNotAllowed = 2;
}

class NSURLRequest extends _ObjCWrapper {
  NSURLRequest._(ffi.Pointer<ObjCObject> id, URLCacheLibrary lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURLRequest] that points to the same underlying object as [other].
  static NSURLRequest castFrom<T extends _ObjCWrapper>(T other) {
    return NSURLRequest._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSURLRequest] that wraps the given raw object pointer.
  static NSURLRequest castFromPointer(
      URLCacheLibrary lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURLRequest._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURLRequest].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSURLRequest1);
  }
}

class NSDate extends _ObjCWrapper {
  NSDate._(ffi.Pointer<ObjCObject> id, URLCacheLibrary lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSDate] that points to the same underlying object as [other].
  static NSDate castFrom<T extends _ObjCWrapper>(T other) {
    return NSDate._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSDate] that wraps the given raw object pointer.
  static NSDate castFromPointer(
      URLCacheLibrary lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSDate._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSDate].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSDate1);
  }
}

class NSURLSessionDataTask extends _ObjCWrapper {
  NSURLSessionDataTask._(ffi.Pointer<ObjCObject> id, URLCacheLibrary lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURLSessionDataTask] that points to the same underlying object as [other].
  static NSURLSessionDataTask castFrom<T extends _ObjCWrapper>(T other) {
    return NSURLSessionDataTask._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSURLSessionDataTask] that wraps the given raw object pointer.
  static NSURLSessionDataTask castFromPointer(
      URLCacheLibrary lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURLSessionDataTask._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURLSessionDataTask].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSURLSessionDataTask1);
  }
}

class _ObjCBlockBase implements ffi.Finalizable {
  final ffi.Pointer<_ObjCBlock> _id;
  final URLCacheLibrary _lib;
  bool _pendingRelease;

  _ObjCBlockBase._(this._id, this._lib,
      {bool retain = false, bool release = false})
      : _pendingRelease = release {
    if (retain) {
      _lib._Block_copy(_id.cast());
    }
    if (release) {
      _lib._objc_releaseFinalizer11.attach(this, _id.cast(), detach: this);
    }
  }

  /// Releases the reference to the underlying ObjC block held by this wrapper.
  /// Throws a StateError if this wrapper doesn't currently hold a reference.
  void release() {
    if (_pendingRelease) {
      _pendingRelease = false;
      _lib._Block_release(_id.cast());
      _lib._objc_releaseFinalizer11.detach(this);
    } else {
      throw StateError(
          'Released an ObjC block that was unowned or already released.');
    }
  }

  @override
  bool operator ==(Object other) {
    return other is _ObjCBlockBase && _id == other._id;
  }

  @override
  int get hashCode => _id.hashCode;
}

void _ObjCBlock_fnPtrTrampoline(
    ffi.Pointer<_ObjCBlock> block, ffi.Pointer<ObjCObject> arg0) {
  return block.ref.target
      .cast<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ObjCObject> arg0)>>()
      .asFunction<void Function(ffi.Pointer<ObjCObject> arg0)>()(arg0);
}

final _ObjCBlock_closureRegistry = <int, Function>{};
int _ObjCBlock_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void> _ObjCBlock_registerClosure(Function fn) {
  final id = ++_ObjCBlock_closureRegistryIndex;
  _ObjCBlock_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

void _ObjCBlock_closureTrampoline(
    ffi.Pointer<_ObjCBlock> block, ffi.Pointer<ObjCObject> arg0) {
  return _ObjCBlock_closureRegistry[block.ref.target.address]!(arg0);
}

class ObjCBlock extends _ObjCBlockBase {
  ObjCBlock._(ffi.Pointer<_ObjCBlock> id, URLCacheLibrary lib)
      : super._(id, lib, retain: false, release: true);

  /// Creates a block from a C function pointer.
  ObjCBlock.fromFunctionPointer(
      URLCacheLibrary lib,
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ObjCObject> arg0)>>
          ptr)
      : this._(
            lib._newBlock1(
                ffi.Pointer.fromFunction<
                            ffi.Void Function(ffi.Pointer<_ObjCBlock> block,
                                ffi.Pointer<ObjCObject> arg0)>(
                        _ObjCBlock_fnPtrTrampoline)
                    .cast(),
                ptr.cast()),
            lib);

  /// Creates a block from a Dart function.
  ObjCBlock.fromFunction(
      URLCacheLibrary lib, void Function(ffi.Pointer<ObjCObject> arg0) fn)
      : this._(
            lib._newBlock1(
                ffi.Pointer.fromFunction<
                            ffi.Void Function(ffi.Pointer<_ObjCBlock> block,
                                ffi.Pointer<ObjCObject> arg0)>(
                        _ObjCBlock_closureTrampoline)
                    .cast(),
                _ObjCBlock_registerClosure(fn)),
            lib);
  void call(ffi.Pointer<ObjCObject> arg0) {
    return _id.ref.invoke
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<_ObjCBlock> block,
                    ffi.Pointer<ObjCObject> arg0)>>()
        .asFunction<
            void Function(ffi.Pointer<_ObjCBlock> block,
                ffi.Pointer<ObjCObject> arg0)>()(_id, arg0);
  }

  ffi.Pointer<_ObjCBlock> get pointer => _id;
}

class _ObjCBlockDesc extends ffi.Struct {
  @ffi.UnsignedLong()
  external int reserved;

  @ffi.UnsignedLong()
  external int size;

  external ffi.Pointer<ffi.Void> copy_helper;

  external ffi.Pointer<ffi.Void> dispose_helper;

  external ffi.Pointer<ffi.Char> signature;
}

class _ObjCBlock extends ffi.Struct {
  external ffi.Pointer<ffi.Void> isa;

  @ffi.Int()
  external int flags;

  @ffi.Int()
  external int reserved;

  external ffi.Pointer<ffi.Void> invoke;

  external ffi.Pointer<_ObjCBlockDesc> descriptor;

  external ffi.Pointer<ffi.Void> target;
}
